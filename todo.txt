1. Get rid of dereferencing type-punned pointers, it's undefined behaviour.
[ Completed ✓ ]

2. Remove checks for non-null ptrs in cleanup paths. Free accepts NULL pointers.
[ Completed ✓ ]

3. Rewrite lost code for finding new diffie-hellman ~ 3072-bit primes.
[ Completed ✓ ]

4. Finish function pointers for AF_UNIX vs Internet socket function variants.
[ Completed ✓ ]

5. Implement the rest of the Rosetta Test Framework with AF_UNIX communication.
[ In progress ] ==> IN SERVER: The thread checking for lost connections needs to
                               have a way to tell a lost client's poll listening
                               thread to stop and return. identify_new_trans is
                               doing it by returning 100 and that client's poll
                               listening thread (its caller) knows to return,
                               but it doesn't have a way to get notified to ret
                               also by the lost connections checker thread.
                               Perhaps a signal handler for SIGUSR1 in each
                               client's poll listen thread and the lost conns
                               thread can send a lost client's poll listener the
                               signal, and thats how that client's listener 
                               thread knows it has to return.

                ==> IN SERVER: Polling needs to start right after login, not
                               when the client joins/creates a chatroom. Becase
                               now, if the client logs in, turns Rosetta off and
                               disappears, the server keeps thinking that client
                               is still logged in. That way we also won't need
                               3 separate global index arrays for:
                                   - user index
                                   - socket index
                                   - thread index

                               ALL would be unified under the same user_ix,
                               vastly simplying the design and bookkeeping.

6. If a user relogs quickly, server says Public Key already exists and does not
   permit the user to log back in. Fix it.

7. Get a clean compile with -O3 on all 10,000+ lines of code, not just -O2.

8. Run linters and static analyzers/sanitizers from GCC/clang, plus Valgrind.

9. Montgomery Modular Multiplication is currently hardcoded to use the same      
   Diffie-Hellman modulus M as its multiplication modulus. It doesn't have to be 
   that way. Computing MU and L (the 2 parameters that depend on the Montgomery  
   Modulus) is simple - L is the number of 64-bit limbs (8-byte chunks) in the   
   Montgomery Modulus, MU is the multiplicative inverse, the algorithm to get it 
   for any Montgomery Modulus is only a few lines of code. Make it so that       
   Montgomery Modular Multiplication takes any modulus, gets L and MU for it,    
   and successfully performs fast modular multiplication and powering. Then it   
   will be usable even in Rabin-Miller primality test, which will significantly  
   speed it up I assume. 

?. Replace if(ret_err){print_err; return;}else{print_good;} with a #define that
   uses __LINE__ and __FILE__ instead of specific strings for all error types.

?. Fix argon2 implementation to work for further passes too.

?. Write benchmarks and correctness tests for BigInt/Cryptography algorithms.

?. Rewrite Montgomery Modular Multiplication w/ intrinsics for more CPUs.

?. Make cryptography algorithms constant-time to avoid side channel attacks.

?. Write a full fledged documentation + description for Rosetta.

?. Specify exactly what global/local state bookkeeping is needed by each
   function (especially packet processing) in Server and Client.

?. Come up with a better unique packet ID numbering. Currently the same packet
   ID exists in server and in client. BAD!

?. Make a better interface for gen_pub_key to not require the private key
   in a temporary file.

?. Get rid of having to manually free the .bits buffer of bigints. Instead,
   implement some bigint destruction strategy or at least a simple API.
